using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace ChainsOfFate.Gerallt
{
    public abstract class CharacterBase : MonoBehaviour, IDescriptive
    {
        public States currentState = States.NotSet;
        
        public enum States
        {
            NotSet = 0,
            Defending = 1,
            AttackingWeapon = 2,
            AttackingSpell = 3,
            Fleeing = 4,
            UsingItem = 5,
            Encouraging = 6,
            Taunting = 7
        }
        
        /// <summary>
        /// A move that is scheduled to be applied later on.
        /// </summary>
        public abstract class AppliedMove
        {
            
        }

        // public class AttackMove : AppliedMove
        // {
        //     public float totalDamage;
        // }
        
        // public class DefenceMove : AppliedMove
        // {
        //     public float blockPercentage;
        // }
        
        #region Fields
        
        /// <summary>
        /// The ID of the character. Internally generated by a GUID.
        /// No need to manually set this.
        /// </summary>
        private string id; 
        
        public int maxHealth = 100;
        public int maxArcana = 100;
        public int maxResolve = 100;
        public int maxWisdom = 100;
        
        public int encouragePercent = 35;
        public int tauntPercent = 35;

        public Color representation;
        
        public List<WeaponBase> availableWeapons;
        public List<SpellBase> availableSpells;
        public List<ItemBase> availableItems;

        [SerializeField] private string characterName;
        
        [SerializeField] private int hp = 100;

        [SerializeField] private int arcana = 100;

        [SerializeField] private int resolve = 100;

        [SerializeField] private int defense = 0;

        [SerializeField] private int wisdom = 0;

        [SerializeField] private int speed = 0;

        [SerializeField] private int strength = 0;

        [SerializeField] private float movementSpeed = 1.0f;

        [SerializeField] private int level = 0;

        [SerializeField] private int xp = 0;
        
        /// <summary>
        /// Schedule of moves the character has applied for their turn.
        /// </summary>
        [SerializeField] private List<AppliedMove> appliedMovesList = new List<AppliedMove>();

        #endregion

        #region Properties

        public string ID => id;
        
        public string CharacterName
        {
            get => characterName;
            set
            {
                characterName = value;
                RaiseStatChanged("CharacterName", value);
            }
        }
        
        public int HP
        {
            get => hp;
            set
            {
                hp = value;
                RaiseStatChanged("HP", value);
            }
        }

        public int Arcana
        {
            get => arcana;
            set
            {
                arcana = value;
                RaiseStatChanged("Arcana", value);
            }
        }

        public int Resolve
        {
            get => resolve;
            set
            {
                resolve = value;
                RaiseStatChanged("Resolve", value);
            }
        }

        public int Defense
        {
            get => defense;
            set
            {
                defense = value;
                RaiseStatChanged("Defense", value);
            }
        }

        public int Wisdom
        {
            get => wisdom;
            set
            {
                wisdom = value;
                RaiseStatChanged("Wisdom", value);
            }
        }

        public int Speed
        {
            get => speed;
            set
            {
                speed = value;
                RaiseStatChanged("Speed", value);
            }
        }

        public int Strength
        {
            get => strength;
            set
            {
                strength = value;
                RaiseStatChanged("Strength", value);
            }
        }

        public float MovementSpeed
        {
            get => movementSpeed;
            set
            {
                movementSpeed = value;
                RaiseStatChanged("MovementSpeed", value);
            }
        }

        public int Level
        {
            get => level;
            set
            {
                level = value;
                RaiseStatChanged("Level", value);
            }
        }
        
        public int XP
        {
            get => xp;
            set
            {
                xp = value;
                RaiseStatChanged("XP", value);
            }
        }

        #endregion

        // Unity can't serialise properties which is a shame. Because when properties change we could call RaiseStatChanged() internally.
        public delegate void StatChangeDelegate(CharacterBase character, string propertyName, object newValue);

        public event StatChangeDelegate OnStatChanged;

        /// <summary>
        /// Apply the damage to health later when the player processed moves applied to them.
        /// </summary>
        /// <param name="damage"></param>
        public virtual void AddDamage(int damage, CharacterBase attacker)
        {
            // Individual characters implement this differently.
        }
        
        /// <summary>
        /// Actually apply the damage to health right now.
        /// </summary>
        public virtual void ApplyDamage(int damage)
        {
            int hitPoints = HP;
            
            hitPoints -= damage;
            
            if (hitPoints < 0)
            {
                hitPoints = 0;
            }

            if (hitPoints > maxHealth)
            {
                hitPoints = maxHealth;
            }
            
            HP = hitPoints;
        }
        
        /// <summary>
        /// Actually apply reducing the arcana by the specified cost right now.
        /// </summary>
        public virtual void ReduceArcana(int spellCost)
        {
            int arc = Arcana;
            
            arc -= spellCost;
            
            if (arc < 0)
            {
                arc = 0;
            }

            if (arc > maxArcana)
            {
                arc = maxArcana;
            }
            
            Arcana = arc;
        }

        /// <summary>
        /// Actually apply change to the resolve right now.
        /// </summary>
        public virtual void ApplyResolve(int resolveChange)
        {
            int res = Resolve;
            
            res += resolveChange;
            
            if (res < 0)
            {
                res = 0;
            }

            if (res > maxResolve)
            {
                res = maxResolve;
            }
            
            Resolve = res;
        }
        
        /// <summary>
        /// Actually apply change to the resolve right now.
        /// </summary>
        public virtual void ApplyWisdom(int wisdomChange)
        {
            int wis = Wisdom;
            
            wis += wisdomChange;
            
            if (wis < 0)
            {
                wis = 0;
            }

            if (wis > maxWisdom)
            {
                wis = maxWisdom;
            }
            
            Wisdom = wis;
        }
        
        public virtual void UpdatePrimaryStats()
        {
            RaiseStatChanged("ID", ID);
            RaiseStatChanged("CharacterName", CharacterName);
            RaiseStatChanged("HP", HP);
            RaiseStatChanged("Resolve", Resolve);
            RaiseStatChanged("Arcana", Arcana);
            RaiseStatChanged("Wisdom", Wisdom);
            RaiseStatChanged("XP", XP);
        }

        public List<AppliedMove> GetMoves()
        {
            return appliedMovesList;
        }
        
        public void ApplyMove(AppliedMove move)
        {
            appliedMovesList.Add(move);
        }

        public void RemoveMove(AppliedMove move)
        {
            appliedMovesList.Remove(move);
        }
        
        public void ClearMoves()
        {
            appliedMovesList.Clear();
        }

        public string GetId()
        {
            return ID;
        }
        
        public string GetName()
        {
            return CharacterName;
        }

        public string GetDescription()
        {
            return string.Empty;
        }

        public Color GetTint()
        {
            return representation;
        }

        public List<IDescriptive> GetInventory()
        {
            List<IDescriptive> allItems = new List<IDescriptive>();
            allItems.AddRange(availableWeapons);
            allItems.AddRange(availableSpells);
            allItems.AddRange(availableItems);
            return allItems;
        }

        public void RemoveItem(IDescriptive item)
        {
            int i = 0;
            if (item is WeaponBase) // TODO: Refactor this generalising item lists into one IDescriptive list
            {
                WeaponBase weapon = item as WeaponBase;
                foreach (WeaponBase w in availableWeapons)
                {
                    if (w.ID == weapon.ID)
                    {
                        availableWeapons.RemoveAt(i);
                        break;
                    }
                    i++;
                }
            }
            else if (item is SpellBase)
            {
                SpellBase spell = item as SpellBase;
                foreach (SpellBase s in availableSpells)
                {
                    if (s.ID == spell.ID)
                    {
                        availableSpells.RemoveAt(i);
                        break;
                    }
                    i++;
                }
            }
            else if (item is ItemBase)
            {
                ItemBase itemBase = item as ItemBase;
                foreach (ItemBase it in availableItems)
                {
                    if (it.ID == itemBase.ID)
                    {
                        availableItems.RemoveAt(i);
                        break;
                    }
                    i++;
                }
            }
        }
        
        public void ResetState()
        {
            currentState = States.NotSet;
        }
        
        protected void RaiseStatChanged(string propertyName, object newValue)
        {
            OnStatChanged?.Invoke(this, propertyName, newValue);
        }

        public virtual void Awake()
        {
            Guid newId = Guid.NewGuid(); //TODO: Check for collisions with characters that by pure unluck might have the same GUID.
            id = newId.ToString();
        }
    }
}